Syntax:
	improve error recovery and messages

IR:
	statements:
		WRITE, FORMAT
	ask for external linkage as a feature. if not, we don't need to keep external linkage, which will allow for aggressive opts in llvm
	testing + debugging
	refactor parser.y
	link with Library
	furnish code with proper deallocations (for example unlink the tmpfile, all the structures we use, ...) and put them in cleanup (and the temps in the proper places)

Cleanup:
	leak:	pzc.lex:90		->	id allocation
	leak:	ir.c:49			->	creating an array for GEP (of some sort - i dont remember)
	leak:	parser.y:461	->	creating name string for reference variables
	leak:	symbol.c:539	->	creating new element to return
	leak:	pzc.lex:130		->	creating new string token to return
	leak:	pzc.lex:*		->	any token with new() call
	leak:	ir.c:188		->	function call frame argument list allocation
	leak:	ir.c:*			->	anything that has to do with function call frames

General:
	compiler arguments and llvm backend invocation (link together?)
	refactor parser.y

Done:
*	leak:	tmpfile			->	does not delete tmpfile
*	leak:	general.c:83	->	what about closing general scope?
*	static compilation invocation	-> call llc and opt (opt done, only llc remains :: llc finished too)
*	fix LLVMPrintModulToFile to properly accept file name (it could have something to do with file creation flags in open())
*	command line parameter parsing	-> mostly done :: have to propagate flags to llc and opt
*	stricter array parameter size checking
*	pass-by-reference parameters
*	functions with a return value are not emitted without an assignment
*	replace currentCallType and currentParam with CallTypeStack and ParamStack
*	loop_counter is not needed for anything else than checking if continue and break statements are legal, remove it. We have break_is_legal, but atm it doesn't function with continue statements.	-> %s/break_is_legal/control_flow_flags/gc' ed.
*	statemets: if, for, while, do..until, switch
*	global array initializations 
*	IR - global variables
*	IR - global constants
*	IR - constant expression assignments
*	IR - array initializations 
*	IR - assignments
*	IR - binops + signed operations
*	IR - unops
*	signed operations handling
*	parser.y cleanup and polishing
*	refactor comp_lib	:: Done, moved to semantic
*	test forward function declarations
*	break is not error. it is statement. instead we must use contexts to check for constructs that use loops, so that we can assign value to break or continue statements
*	real constants : atof already converts between them
*	l_value++
*	return statement type checking
*	function calls
-	array sizes
*	refactor error reporting
*	substitute error.c functions for my_error
*	control_flow_flags inheritance schema:
		if(X)		->	X
		while(X)	->	X | 01
		do(X)		->	X | 01
		for(X)		->	X | 01
		switch(X)	->	X | 10
	>>
		switch break is indicated by 1X bit, and while control flow is indicated by X1 bit.
*	function declarations and calls
*	capture llvm stream ( dump to file? )
